name: Deploy Backend (api.gitlingo.app)

on:
  push:
    branches: ["master"]
    paths:
      - "backend/**"
      - ".github/workflows/deploy-backend.yml"

permissions:
  contents: read

concurrency:
  group: deploy-backend
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Package backend source
        run: |
          set -euo pipefail
          tar -czf backend-src.tgz -C backend .

      - name: Upload backend tarball to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VULTR_SSH_HOST }}
          username: ${{ secrets.VULTR_SSH_USER }}
          key: ${{ secrets.VULTR_SSH_KEY }}
          port: ${{ secrets.VULTR_SSH_PORT }}
          source: "backend-src.tgz"
          target: "/tmp/gitlingo-deploy/"

      - name: Deploy on server (blue/green + health gate)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VULTR_SSH_HOST }}
          username: ${{ secrets.VULTR_SSH_USER }}
          key: ${{ secrets.VULTR_SSH_KEY }}
          port: ${{ secrets.VULTR_SSH_PORT }}
          script: |
            set -euo pipefail

            TS="$(date +%Y%m%d-%H%M%S)"
            BASE="/opt/gitlingo/backend"
            REL="$BASE/releases/$TS"
            PKG="/tmp/gitlingo-deploy/backend-src.tgz"
            SHARED="$BASE/shared"
            ACTIVE_FILE="$SHARED/active_color"

            mkdir -p "$BASE/releases" "$SHARED/router" "$REL"
            test -f "$PKG"

            # Unpack release
            tar -xzf "$PKG" -C "$REL"
            test -f "$REL/docker-compose.yml"
            test -f "$REL/Dockerfile"

            # Atomic switch current -> new release
            ln -sfn "$REL" "$BASE/current"

            # Ensure shared .env exists (kept outside releases)
            if [ ! -f "$SHARED/.env" ]; then
              echo "ERROR: Missing $SHARED/.env"
              exit 1
            fi

            # Link shared env + router configs into the current release
            ln -sfn "$SHARED/.env" "$BASE/current/.env"
            ln -sfn "$SHARED/router/nginx.conf" "$BASE/current/router/nginx.conf"
            ln -sfn "$SHARED/router/upstream.conf" "$BASE/current/router/upstream.conf"

            # Decide active/next color
            ACTIVE="blue"
            if [ -f "$ACTIVE_FILE" ]; then ACTIVE="$(cat "$ACTIVE_FILE")"; fi
            if [ "$ACTIVE" = "blue" ]; then NEXT="green"; else NEXT="blue"; fi

            echo "ACTIVE=$ACTIVE NEXT=$NEXT"

            cd "$BASE/current"

            # Ensure router configs exist (first deploy)
            if [ ! -f "$SHARED/router/nginx.conf" ]; then
              echo "ERROR: Missing $SHARED/router/nginx.conf"
              exit 1
            fi
            if [ ! -f "$SHARED/router/upstream.conf" ]; then
              echo "Initializing upstream.conf to api_${ACTIVE}"
              printf "upstream gitlingo_backend {\n  server api_%s:3001;\n}\n" "$ACTIVE" > "$SHARED/router/upstream.conf"
            fi

            # Build/start NEXT with a new image tag
            export COMPOSE_PROJECT_NAME="gitlingo-backend"
            export GITLINGO_IMAGE_TAG="$TS"

            # Always ensure router is up (it will just reload later)
            docker compose up -d router

            # Build + start NEXT service only (keep ACTIVE running)
            docker compose build "api_${NEXT}"
            docker compose up -d --no-deps --force-recreate "api_${NEXT}"

            # Wait for NEXT to become healthy
            CID="$(docker compose ps -q "api_${NEXT}")"
            if [ -z "$CID" ]; then
              echo "ERROR: Could not get container id for api_${NEXT}"
              exit 1
            fi

            echo "Waiting for api_${NEXT} to be healthy..."
            for i in $(seq 1 90); do
              STATUS="$(docker inspect -f '{{.State.Health.Status}}' "$CID" 2>/dev/null || true)"
              if [ "$STATUS" = "healthy" ]; then
                echo "api_${NEXT} is healthy"
                break
              fi
              if [ "$STATUS" = "unhealthy" ]; then
                echo "api_${NEXT} became unhealthy"
                docker compose logs --tail=200 "api_${NEXT}" || true
                exit 1
              fi
              sleep 2
              if [ "$i" -eq 90 ]; then
                echo "Timed out waiting for api_${NEXT} health"
                docker compose logs --tail=200 "api_${NEXT}" || true
                exit 1
              fi
            done

            # Switch router upstream to NEXT and reload router (near-zero downtime)
            printf "upstream gitlingo_backend {\n  server api_%s:3001;\n}\n" "$NEXT" > "$SHARED/router/upstream.conf"
            docker compose exec -T router nginx -s reload

            echo "$NEXT" > "$ACTIVE_FILE"

            # Give existing connections a brief chance to drain, then stop old ACTIVE
            sleep 8
            docker compose stop "api_${ACTIVE}" || true

            # Cleanup tarball
            rm -f "$PKG"

            # Keep last 3 releases
            cd "$BASE/releases"
            ls -1dt */ | tail -n +4 | xargs -r rm -rf

            # Prune dangling images
            docker image prune -f >/dev/null 2>&1 || true

            echo "Deployed backend release: $TS (active=$NEXT)"